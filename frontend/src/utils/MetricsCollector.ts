/**
 * Metrics Collector: Data gathering for monitoring system
 *
 * Purpose: Track intervention effectiveness, user engagement, fatigue patterns
 *
 * Tracks:
 * 1. Detection Metrics: When patterns detected, detection accuracy
 * 2. Intervention Metrics: Display count, dismissal rate, engagement rate
 * 3. Compliance Metrics: % users who acted after intervention
 * 4. Fatigue Metrics: When suppression triggered, how long users were fatigued
 * 5. Performance Metrics: Detection latency, UI render time
 * 6. Outcome Metrics: Session completion, dropout correlation
 */

import { ComplianceMetrics } from '../types';

/**
 * Detailed metrics for a single intervention display
 */
export interface InterventionRecord {
  id: string;
  sessionId: string;
  timestamp: number;

  // Detection info
  mrType: string;
  patternType: string;
  confidence: number;
  triggeredRules: string[];
  tier: 'soft' | 'medium' | 'hard';

  // User action
  userAction?: 'dismiss' | 'skip' | 'acted' | 'override';
  actionTimestamp?: number;
  timeToAction?: number; // ms from display to action

  // Context
  fatigueScore?: number;
  suppressionActive?: boolean;
  messageCountAtDisplay?: number;
}

/**
 * Session-level metrics aggregated from intervention records
 */
export interface SessionMetrics {
  sessionId: string;
  userId: string;
  startTime: number;
  endTime?: number;

  // Detection stats
  totalDetections: number;
  averageConfidence: number;
  patternTypeBreakdown: Record<string, number>; // { 'MR18': 2, 'MR20': 1 }

  // Intervention display stats
  totalDisplays: number;
  tierBreakdown: Record<string, number>; // { 'soft': 5, 'medium': 2, 'hard': 1 }

  // User action stats
  dismissalCount: number;
  dismissalRate: number; // 0-1
  engagementCount: number;
  engagementRate: number; // 0-1
  complianceCount: number;
  complianceRate: number; // 0-1
  overrideCount: number;
  overrideRate: number; // 0-1

  // Timing stats
  avgTimeToAction: number; // ms
  avgDetectionLatency: number; // ms

  // Fatigue stats
  suppressionEvents: number;
  avgFatigueScore: number;
  maxFatigueScore: number;
  timeUnderFatigue: number; // ms

  // Outcome
  sessionCompleted: boolean;
  droppedOut: boolean;
  completionTime: number; // ms
  messageCount: number;
}

/**
 * System-level metrics aggregated from all sessions
 */
export interface SystemMetrics {
  periodStart: number;
  periodEnd: number;

  // Aggregate stats
  totalSessions: number;
  totalDetections: number;
  totalInterventions: number;
  totalUsers: number;

  // Effectiveness
  avgDetectionAccuracy: number; // Based on compliance rates
  avgComplianceRate: number;
  avgDismissalRate: number;
  avgEngagementRate: number;
  avgOverrideRate: number;

  // Performance
  p50DetectionLatency: number; // ms
  p95DetectionLatency: number; // ms
  p99DetectionLatency: number; // ms

  // Patterns
  mostCommonPatterns: Array<{ type: string; count: number }>;
  mostEffectiveTier: 'soft' | 'medium' | 'hard';
  mostCommonDismissalReason?: string;

  // Quality
  falsePositiveRate: number; // % of detections that user overrode
  completionRate: number; // % sessions completed
  dropoutRate: number; // % sessions dropped

  // Alerts triggered
  alertsTriggered: number;
  criticalAlertsTriggered: number;
}

/**
 * Alert threshold configuration
 */
export interface AlertThresholds {
  // Dismissal thresholds
  dismissalRateHigh: number; // > 0.7 = high dismissal
  dismissalCountWarning: number; // >= 5 dismissals = warning

  // Compliance thresholds
  complianceRateLow: number; // < 0.3 = low compliance

  // Fatigue thresholds
  fatigueScoreHigh: number; // > 70 = high fatigue
  suppressionEventWarning: number; // >= 3 events = warning

  // Performance thresholds
  detectionLatencyHigh: number; // > 200ms = high latency

  // Outcome thresholds
  dropoutRateHigh: number; // > 0.2 = high dropout
}

/**
 * Alert generated by the system
 */
export interface SystemAlert {
  id: string;
  timestamp: number;
  severity: 'info' | 'warning' | 'critical';
  type: string; // 'high_dismissal', 'low_compliance', 'high_fatigue', 'high_latency', 'high_dropout'
  message: string;
  sessionId?: string;
  data: Record<string, any>;
  acknowledged?: boolean;
  acknowledgedAt?: number;
}

/**
 * Main metrics collector class
 */
export class MetricsCollector {
  private interventionRecords: Map<string, InterventionRecord[]> = new Map(); // sessionId -> records
  private sessionMetrics: Map<string, SessionMetrics> = new Map();
  private systemMetrics: SystemMetrics;
  private alerts: SystemAlert[] = [];
  private detectionLatencies: number[] = [];

  private thresholds: AlertThresholds = {
    dismissalRateHigh: 0.7,
    dismissalCountWarning: 5,
    complianceRateLow: 0.3,
    fatigueScoreHigh: 70,
    suppressionEventWarning: 3,
    detectionLatencyHigh: 200,
    dropoutRateHigh: 0.2,
  };

  constructor() {
    this.systemMetrics = {
      periodStart: Date.now(),
      periodEnd: Date.now(),
      totalSessions: 0,
      totalDetections: 0,
      totalInterventions: 0,
      totalUsers: 0,
      avgDetectionAccuracy: 0,
      avgComplianceRate: 0,
      avgDismissalRate: 0,
      avgEngagementRate: 0,
      avgOverrideRate: 0,
      p50DetectionLatency: 0,
      p95DetectionLatency: 0,
      p99DetectionLatency: 0,
      mostCommonPatterns: [],
      mostEffectiveTier: 'medium',
      completionRate: 0,
      dropoutRate: 0,
      falsePositiveRate: 0,
      alertsTriggered: 0,
      criticalAlertsTriggered: 0,
    };
  }

  /**
   * Record a new intervention display
   */
  recordInterventionDisplay(record: Omit<InterventionRecord, 'id'>) {
    const id = `${record.sessionId}-${record.timestamp}-${Math.random()}`;
    const fullRecord: InterventionRecord = { id, ...record };

    // Store in memory
    if (!this.interventionRecords.has(record.sessionId)) {
      this.interventionRecords.set(record.sessionId, []);
    }
    this.interventionRecords.get(record.sessionId)!.push(fullRecord);

    // Update system metrics
    this.systemMetrics.totalInterventions++;
    this.systemMetrics.totalDetections++;
  }

  /**
   * Record user action on intervention
   */
  recordUserAction(
    sessionId: string,
    interventionId: string,
    action: 'dismiss' | 'skip' | 'acted' | 'override',
    timeToAction: number
  ) {
    const records = this.interventionRecords.get(sessionId) || [];
    const record = records.find((r) => r.id === interventionId);

    if (record) {
      record.userAction = action;
      record.actionTimestamp = Date.now();
      record.timeToAction = timeToAction;
    }
  }

  /**
   * Record detection latency
   */
  recordDetectionLatency(latencyMs: number) {
    this.detectionLatencies.push(latencyMs);

    // Check threshold
    if (latencyMs > this.thresholds.detectionLatencyHigh) {
      this.triggerAlert(
        'high_latency',
        'critical',
        `Detection latency high: ${latencyMs.toFixed(0)}ms (threshold: ${this.thresholds.detectionLatencyHigh}ms)`
      );
    }
  }

  /**
   * Calculate metrics for a completed session
   */
  calculateSessionMetrics(
    sessionId: string,
    userId: string,
    messageCount: number,
    completed: boolean,
    completionTime: number
  ): SessionMetrics {
    const records = this.interventionRecords.get(sessionId) || [];

    // Calculate stats from records
    const totalDisplays = records.length;
    const dismissals = records.filter((r) => r.userAction === 'dismiss').length;
    const engagements = records.filter((r) => r.userAction === 'acted').length;
    const compliances = records.filter((r) => r.userAction === 'acted').length;
    const overrides = records.filter((r) => r.userAction === 'override').length;

    const dismissalRate = totalDisplays > 0 ? dismissals / totalDisplays : 0;
    const engagementRate = totalDisplays > 0 ? engagements / totalDisplays : 0;
    const complianceRate = totalDisplays > 0 ? compliances / totalDisplays : 0;
    const overrideRate = totalDisplays > 0 ? overrides / totalDisplays : 0;

    const avgTimeToAction =
      records
        .filter((r) => r.timeToAction)
        .reduce((sum, r) => sum + (r.timeToAction || 0), 0) / Math.max(records.length, 1);

    const avgConfidence =
      records.reduce((sum, r) => sum + r.confidence, 0) / Math.max(records.length, 1);

    // Tier breakdown
    const tierBreakdown: Record<string, number> = {
      soft: 0,
      medium: 0,
      hard: 0,
    };
    records.forEach((r) => {
      tierBreakdown[r.tier]++;
    });

    // Pattern type breakdown
    const patternTypeBreakdown: Record<string, number> = {};
    records.forEach((r) => {
      patternTypeBreakdown[r.mrType] = (patternTypeBreakdown[r.mrType] || 0) + 1;
    });

    // Fatigue stats
    const suppressionEvents = records.filter((r) => r.suppressionActive).length;
    const avgFatigueScore =
      records.filter((r) => r.fatigueScore).reduce((sum, r) => sum + (r.fatigueScore || 0), 0) /
      Math.max(
        records.filter((r) => r.fatigueScore).length,
        1
      );
    const maxFatigueScore = Math.max(
      ...records.map((r) => r.fatigueScore || 0),
      0
    );

    const metrics: SessionMetrics = {
      sessionId,
      userId,
      startTime: records.length > 0 ? records[0].timestamp : Date.now(),
      endTime: Date.now(),
      totalDetections: records.length,
      averageConfidence: avgConfidence,
      patternTypeBreakdown,
      totalDisplays,
      tierBreakdown,
      dismissalCount: dismissals,
      dismissalRate,
      engagementCount: engagements,
      engagementRate,
      complianceCount: compliances,
      complianceRate,
      overrideCount: overrides,
      overrideRate,
      avgTimeToAction,
      avgDetectionLatency: 0, // Would be calculated from latency records
      suppressionEvents,
      avgFatigueScore,
      maxFatigueScore,
      timeUnderFatigue: 0, // Would be calculated from suppression events
      sessionCompleted: completed,
      droppedOut: !completed,
      completionTime,
      messageCount,
    };

    this.sessionMetrics.set(sessionId, metrics);

    // Check thresholds and trigger alerts
    if (dismissalRate > this.thresholds.dismissalRateHigh && totalDisplays > 0) {
      this.triggerAlert(
        'high_dismissal',
        'warning',
        `High dismissal rate: ${(dismissalRate * 100).toFixed(1)}% (threshold: ${(this.thresholds.dismissalRateHigh * 100).toFixed(0)}%)`,
        sessionId
      );
    }

    if (complianceRate < this.thresholds.complianceRateLow && totalDisplays > 0) {
      this.triggerAlert(
        'low_compliance',
        'warning',
        `Low compliance rate: ${(complianceRate * 100).toFixed(1)}% (threshold: ${(this.thresholds.complianceRateLow * 100).toFixed(0)}%)`,
        sessionId
      );
    }

    if (avgFatigueScore > this.thresholds.fatigueScoreHigh) {
      this.triggerAlert(
        'high_fatigue',
        'warning',
        `High fatigue score: ${avgFatigueScore.toFixed(1)} (threshold: ${this.thresholds.fatigueScoreHigh})`,
        sessionId
      );
    }

    if (!completed) {
      this.triggerAlert(
        'session_dropout',
        'warning',
        `Session dropped out after ${messageCount} messages`,
        sessionId
      );
    }

    return metrics;
  }

  /**
   * Aggregate system metrics from all sessions
   */
  aggregateSystemMetrics(): SystemMetrics {
    const allMetrics = Array.from(this.sessionMetrics.values());
    const totalSessions = allMetrics.length;

    if (totalSessions === 0) {
      return this.systemMetrics;
    }

    // Calculate averages
    const avgComplianceRate =
      allMetrics.reduce((sum, m) => sum + m.complianceRate, 0) / totalSessions;
    const avgDismissalRate =
      allMetrics.reduce((sum, m) => sum + m.dismissalRate, 0) / totalSessions;
    const avgEngagementRate =
      allMetrics.reduce((sum, m) => sum + m.engagementRate, 0) / totalSessions;
    const avgOverrideRate =
      allMetrics.reduce((sum, m) => sum + m.overrideRate, 0) / totalSessions;

    // Completion stats
    const completedSessions = allMetrics.filter((m) => m.sessionCompleted).length;
    const completionRate = completedSessions / totalSessions;
    const dropoutRate = 1 - completionRate;

    // False positive rate (overrides / total)
    const totalInterventions = allMetrics.reduce((sum, m) => sum + m.totalDisplays, 0);
    const totalOverrides = allMetrics.reduce((sum, m) => sum + m.overrideCount, 0);
    const falsePositiveRate = totalInterventions > 0 ? totalOverrides / totalInterventions : 0;

    // Detection latency percentiles
    const sorted = [...this.detectionLatencies].sort((a, b) => a - b);
    const p50 = sorted[Math.floor(sorted.length * 0.5)] || 0;
    const p95 = sorted[Math.floor(sorted.length * 0.95)] || 0;
    const p99 = sorted[Math.floor(sorted.length * 0.99)] || 0;

    // Most common patterns
    const patternCounts: Record<string, number> = {};
    allMetrics.forEach((m) => {
      Object.entries(m.patternTypeBreakdown).forEach(([pattern, count]) => {
        patternCounts[pattern] = (patternCounts[pattern] || 0) + count;
      });
    });
    const mostCommonPatterns = Object.entries(patternCounts)
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Most effective tier
    const tierStats: Record<string, { displayed: number; complied: number }> = {
      soft: { displayed: 0, complied: 0 },
      medium: { displayed: 0, complied: 0 },
      hard: { displayed: 0, complied: 0 },
    };

    allMetrics.forEach((m) => {
      Object.entries(m.tierBreakdown).forEach(([tier, count]) => {
        tierStats[tier].displayed += count;
      });
    });

    // Calculate compliance by tier
    const records = Array.from(this.interventionRecords.values()).flat();
    records.forEach((r) => {
      if (r.userAction === 'acted') {
        tierStats[r.tier].complied++;
      }
    });

    const tierCompliance: Record<string, number> = {};
    Object.entries(tierStats).forEach(([tier, stats]) => {
      tierCompliance[tier] = stats.displayed > 0 ? stats.complied / stats.displayed : 0;
    });

    const mostEffectiveTier = (Object.entries(tierCompliance).sort((a, b) => b[1] - a[1])[0]?.[0] ||
      'medium') as 'soft' | 'medium' | 'hard';

    this.systemMetrics = {
      periodStart: this.systemMetrics.periodStart,
      periodEnd: Date.now(),
      totalSessions,
      totalDetections: this.systemMetrics.totalDetections,
      totalInterventions,
      totalUsers: new Set(allMetrics.map((m) => m.userId)).size,
      avgDetectionAccuracy: 1 - falsePositiveRate,
      avgComplianceRate,
      avgDismissalRate,
      avgEngagementRate,
      avgOverrideRate,
      p50DetectionLatency: p50,
      p95DetectionLatency: p95,
      p99DetectionLatency: p99,
      mostCommonPatterns,
      mostEffectiveTier,
      completionRate,
      dropoutRate,
      falsePositiveRate,
      alertsTriggered: this.alerts.length,
      criticalAlertsTriggered: this.alerts.filter((a) => a.severity === 'critical').length,
    };

    return this.systemMetrics;
  }

  /**
   * Trigger an alert
   */
  private triggerAlert(
    type: string,
    severity: 'info' | 'warning' | 'critical',
    message: string,
    sessionId?: string
  ) {
    // Check if a similar alert was triggered recently (within last 30 seconds)
    const thirtySecondsAgo = Date.now() - 30000;
    const recentSimilarAlert = this.alerts.find(
      (alert) =>
        alert.type === type &&
        alert.timestamp > thirtySecondsAgo &&
        alert.sessionId === sessionId
    );

    // Skip duplicate alerts within 30 seconds
    if (recentSimilarAlert) {
      return;
    }

    const alert: SystemAlert = {
      id: `alert-${Date.now()}-${Math.random()}`,
      timestamp: Date.now(),
      severity,
      type,
      message,
      sessionId,
      data: { type, severity, message },
    };

    this.alerts.push(alert);

    if (severity === 'critical') {
      this.systemMetrics.criticalAlertsTriggered++;
    }
    this.systemMetrics.alertsTriggered++;
  }

  /**
   * Get recent alerts
   */
  getAlerts(limit: number = 10): SystemAlert[] {
    return this.alerts.slice(-limit);
  }

  /**
   * Get session metrics
   */
  getSessionMetrics(sessionId: string): SessionMetrics | undefined {
    return this.sessionMetrics.get(sessionId);
  }

  /**
   * Get all session metrics
   */
  getAllSessionMetrics(): SessionMetrics[] {
    return Array.from(this.sessionMetrics.values());
  }

  /**
   * Get system metrics
   */
  getSystemMetrics(): SystemMetrics {
    return this.aggregateSystemMetrics();
  }

  /**
   * Set alert thresholds
   */
  setThresholds(thresholds: Partial<AlertThresholds>) {
    this.thresholds = { ...this.thresholds, ...thresholds };
  }

  /**
   * Get alert thresholds
   */
  getThresholds(): AlertThresholds {
    return this.thresholds;
  }

  /**
   * Clear alerts older than X minutes
   */
  clearOldAlerts(minutesAgo: number = 60) {
    const cutoffTime = Date.now() - minutesAgo * 60 * 1000;
    this.alerts = this.alerts.filter((a) => a.timestamp > cutoffTime);
  }

  /**
   * Acknowledge an alert
   */
  acknowledgeAlert(alertId: string) {
    const alert = this.alerts.find((a) => a.id === alertId);
    if (alert) {
      alert.acknowledged = true;
      alert.acknowledgedAt = Date.now();
    }
  }

  /**
   * Export metrics as JSON for backend storage
   */
  exportMetrics() {
    return {
      systemMetrics: this.systemMetrics,
      sessionMetrics: Array.from(this.sessionMetrics.values()),
      alerts: this.alerts,
      timestamp: Date.now(),
    };
  }

  /**
   * Reset metrics (for testing)
   */
  reset() {
    this.interventionRecords.clear();
    this.sessionMetrics.clear();
    this.detectionLatencies = [];
    this.alerts = [];
    this.systemMetrics.periodStart = Date.now();
  }
}

// Singleton instance
export const metricsCollector = new MetricsCollector();
